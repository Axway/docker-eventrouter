variables:
  NAME: event-router
  IMAGE_NAME: eventrouter
  NAME_PACK: EventRouter
  DOCKER_REPO_SNAPSHOT: sentineleventrouter-docker-snapshot-ptx.artifactory-ptx.ecd.axway.int
  DOCKER_REPO_RELEASE: sentineleventrouter-docker-release-ptx.artifactory-ptx.ecd.axway.int
  RPM_REPO_SNAPSHOT: https://artifactory-ptx.ecd.axway.int/artifactory/sentineleventrouter-generic-snapshot-ptx
  RPM_REPO_RELEASE: https://artifactory-ptx.ecd.axway.int/artifactory/sentineleventrouter-generic-release-ptx
  CURL_IMAGE: "davinci1976/docker-ci:unstable"
  CURL_AXWAY: "curl --cacert ./AxwayRootCA.cer"
  SHA_RELEASE: ""

  # Security images
  #BLACKDUCK_DOCKER_IMAGE: psg-docker-release.artifactory-ptx.ecd.axway.int/blackduck:latest # impossible to add packages to this image
  BLACKDUCK_DOCKER_IMAGE: openjdk:23-slim-bullseye
  FORTIFY_DOCKER_IMAGE: psg-docker-release.artifactory-ptx.ecd.axway.int/fortify/fortify-mvn-jdk-8:latest
  TWISTLOCK_IMAGE: psg-docker-release.artifactory-ptx.ecd.axway.int/psg-tools/docker:latest
  BLACK_DUCK_PROJECT_NAME: "MFT - Sentinel Event Router"
  BLACK_DUCK_PROJECT_VERSION: "SNAPSHOT"
#include:
#  - template: Code-Quality.gitlab-ci.yml

default:
  tags:
    - docker-ex
  before_script:
    - eval export CI_COMMIT_BRANCH=$(echo "${CI_COMMIT_BRANCH:-$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}" | tr '[:upper:]' '[:lower:]')
    - echo using commit $CI_COMMIT_BRANCH
    - eval export DOCKER_IMAGE=$DOCKER_REPO_SNAPSHOT/$IMAGE_NAME:$CI_COMMIT_BRANCH
    - echo using image $DOCKER_IMAGE
    - eval export REVISION=$(echo "$CI_COMMIT_SHA" | cut -c 1-10)
stages:
  - prepare
  - build
  - pack
  - test
  - deploy
  - preparesecurity
  - security
  - cleansecurity

version:
  image: davinci1976/docker-ci:unstable
  stage: prepare
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  script:
    - ./scripts/setVersion.sh
  artifacts:
    paths:
      - ./.env

unit-test:
  image: docker
  stage: prepare
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  #coverage: "/\\(statements\\)(?:\\s+)?(\\d+(?:\\.\\d+)?%)/"
  script:
    - ./scripts/run-unit-test-docker.sh
  artifacts:
    reports:
      junit: report.xml

.build:
  image: golang:bookworm
  stage: build
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  cache:
    paths:
      - .cache/
    key: GO
  script:
    - (test -d /artefacts && ln -s /artefacts ./artefacts) || mkdir -p artefacts
    - ls -l .cache || true
    - mkdir -p .cache
    - export GOPATH="$CI_PROJECT_DIR/.cache"
    - make build-glibc
    - ./$NAME version
    - cp $NAME ./artefacts/
  artifacts:
    paths:
      - ./artefacts/$NAME
    expire_in: 2 day

build-glibc:
  image: docker
  stage: build
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  script:
    - (test -d /artefacts && ln -s /artefacts ./artefacts) || mkdir -p artefacts
    - ./scripts/run-build-docker.sh
    - chmod +x $NAME
    - cp $NAME ./artefacts/
  artifacts:
    paths:
      - ./artefacts/$NAME

build-docker:
  image: davinci1976/docker-ci:unstable
  stage: build
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  script:
    - . ./.env
    - docker build --pull -f ./docker/Dockerfile -t $DOCKER_IMAGE .
    - docker run --env ACCEPT_GENERAL_CONDITIONS=YES --rm $DOCKER_IMAGE $NAME version

integration-test-reset:
  image: docker
  needs: []
  when: manual
  stage: test
  #coverage: "/\\(statements\\)(?:\\s+)?(\\d+(?:\\.\\d+)?%)/"
  script:
    - ./scripts/run-integration-test-docker.sh reset
  artifacts:
    when: always
    reports:
      junit: report.xml
      #coverage_report:
      #  coverage_format: cobertura
      #  path: coverage.xml

integration-test:
  image: docker
  stage: test
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  cache:
    paths:
      - .cache/
    key: GO
  coverage: "/\\(statements\\)(?:\\s+)?(\\d+(?:\\.\\d+)?%)/"
  script:
    - ./scripts/run-integration-test-docker.sh
  artifacts:
    when: always
    paths:
      - coverage.svg
    reports:
      junit: report.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

rpm-pack:
  image: golang:1.23
  stage: pack
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  script:
    - apt-get update -y
    - apt-get install rpm -y
    - test -d /artefacts && ln -s /artefacts ./artefacts
    - . ./.env
    - ./rpm/rpm-build.sh $NAME ${VERSION}
  artifacts:
    paths:
      - ./artefacts/$NAME*.rpm
    expire_in: 2 day

rpm-test:
  image: davinci1976/docker-ci:unstable
  stage: test
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger"
  script:
    #- test ! -e ./artefacts && ln -s /artefacts ./artefacts
    - test ! -e ./artefacts && cp -rf /artefacts ./artefacts/
    - ./rpm/rpm-test.sh $NAME

rpm-snapshot:
  image: $CURL_IMAGE
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger" && $SHA_RELEASE == ""
  dependencies:
    - version
    - rpm-pack
  script:
    - . ./.env
    - if [ "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" != "" ] ; then
    -     version="${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
    - else
    -     version="${VERSION}"
    - fi
    - datetime=$(date -u +'%Y%m%d%H%M')
    - $CURL_AXWAY -k -v -u $ARTIFACTORY_USER:$ARTIFACTORY_TOKEN -T ./artefacts/$NAME*.rpm "$RPM_REPO_SNAPSHOT/${version}/${NAME_PACK}_${CI_COMMIT_BRANCH}_${datetime}_${REVISION}.rpm"

docker-snapshot:
  image: docker
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_PIPELINE_SOURCE == "trigger" && $SHA_RELEASE == ""
  dependencies:
    - version
  script:
    - . ./.env
    - docker login -u $ARTIFACTORY_USER -p $ARTIFACTORY_TOKEN $DOCKER_REPO_SNAPSHOT
    - eval export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
    - echo VERSION:${VERSION} REVISION:$REVISION BUILD_DATE:$BUILD_DATE CI_MERGE_REQUEST_SOURCE_BRANCH_NAME:$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - if [ "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" != "" ] ; then
    -     branch_arg="--build-arg BANCH_NAME=${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
    - fi
    - docker build --pull -f ./docker/Dockerfile -t $DOCKER_IMAGE --build-arg BUILD_DATE=$BUILD_DATE --build-arg VERSION=${VERSION} --build-arg BUILD_REVISION=${REVISION} ${branch_arg} .
    - docker push $DOCKER_IMAGE

rpm-release:
  image: $CURL_IMAGE
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger" && $SHA_RELEASE != ""
  dependencies:
    - version
    - rpm-pack
  script:
    - . ./.env
    - $CURL_AXWAY -k -v -u $ARTIFACTORY_USER:$ARTIFACTORY_TOKEN -T ./artefacts/$NAME*.rpm "$RPM_REPO_RELEASE/${VERSION:0:-2}/${NAME_PACK}_${VERSION}_${REVISION}_linux-x86-64.rpm"

docker-release:
  image: docker
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger" && $SHA_RELEASE != ""
  dependencies:
    - version
  script:
    - . ./.env
    - eval export DOCKER_IMAGE=$DOCKER_REPO_RELEASE/$IMAGE_NAME:${VERSION}
    - echo using image $DOCKER_IMAGE
    - docker login -u $ARTIFACTORY_USER -p $ARTIFACTORY_TOKEN $DOCKER_REPO_RELEASE
    - eval export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
    - echo VERSION:${VERSION} REVISION:$REVISION BUILD_DATE:$BUILD_DATE
    - docker build --pull -f ./docker/Dockerfile -t $DOCKER_IMAGE --build-arg BUILD_DATE=$BUILD_DATE --build-arg VERSION=${VERSION} --build-arg BUILD_REVISION=${REVISION} .
    - docker push $DOCKER_IMAGE

.security:
  stage: security
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: always
    - when: manual

fortify:
  image: $FORTIFY_DOCKER_IMAGE
  extends: .security
  script:
    - apt-get update -y
    - apt-get install git -y
    - git clone https://cft_read:$GIT_CFT_READ_TOKEN@git.ecd.axway.org/cft/qlt-router.git qlt-router
    - cd qlt-router
    - git checkout master
    - sourceanalyzer -b er_fortify **/src/**/*.go -verbose -logfile ./log.txt
    - scancentral -sscurl $SSC_URL -ssctoken $SSC_CONTROL_TOKEN start -upload -versionid 10854 -uptoken $SSC_UPLOAD_TOKEN -b er_fortify -scan -mt

twistlock:
  image: $TWISTLOCK_IMAGE
  extends: .security
  script:
    - twistcli images scan -u $TWISTLOCK_USER -p "$TWISTLOCK_PASSWORD" --address $TWISTLOCK_URL --details --output-file analysis.json $DOCKER_IMAGE
    # Upload the scan result to SRM
    - "curl --insecure -H \"Authorization: Bearer ${SRM_APIKEY}\" -H \"Accept: application/json\" -X POST --form \"file=@analysis.json\" https://asoc.ssg.axway.int/srm/api/projects/${SRM_PROJECTID}/analysis"
    # Remove scan results.
    - rm -f analysis.json

blackduck:
  image: $BLACKDUCK_DOCKER_IMAGE
  extends: .security
  script:
    - apt-get --allow-releaseinfo-change update
    - apt-get install build-essential make git unzip wget -y --fix-missing
    - wget https://go.dev/dl/go1.23.2.linux-amd64.tar.gz
    - rm -rf /usr/local/go && tar -C /usr/local -xzf go1.23.2.linux-amd64.tar.gz
    - export PATH=/usr/local/go/bin:$PATH
    - go version
    - CI_COMMIT_BRANCH="${CI_COMMIT_BRANCH:-master}"
    - echo using commit $CI_COMMIT_BRANCH
    - git clone https://cft_read:$GIT_CFT_READ_TOKEN@git.ecd.axway.org/cft/qlt-router.git qlt-router
    - cd qlt-router
    - git checkout $CI_COMMIT_BRANCH
    - make
    - cd ..
    - wget --no-check-certificate https://artifactory-ptx.ecd.axway.int/artifactory/psg-generic-release/blackduck/synopsys-detect.zip
    - unzip synopsys-detect.zip -d synopsys-detect
    - if [ $BLACK_DUCK_PROJECT_VERSION != "SNAPSHOT" ]; then
    -   echo "Cloning SNAPSHOT to $BLACK_DUCK_PROJECT_VERSION..."
    -   java -jar synopsys-detect/synopsys-detect.jar --blackduck.url=$BLACK_DUCK_URL --blackduck.api.token=$BLACK_DUCK_TOKEN --detect.project.name="$BLACK_DUCK_PROJECT_NAME" --detect.project.version.name=$BLACK_DUCK_PROJECT_VERSION --detect.clone.project.version.name="SNAPSHOT" --detect.source.path=qlt-router/ --detect.go.path=`which go` --detect.go.mod.dependency.types.excluded=UNUSED --detect.output.path="/blackduck/output" --detect.status.json.output.path="/blackduck/status"
    - else
    -   java -jar synopsys-detect/synopsys-detect.jar --blackduck.url=$BLACK_DUCK_URL --blackduck.api.token=$BLACK_DUCK_TOKEN --detect.project.name="$BLACK_DUCK_PROJECT_NAME" --detect.project.version.name=$BLACK_DUCK_PROJECT_VERSION --detect.source.path=qlt-router/ --detect.go.path=`which go` --detect.go.mod.dependency.types.excluded=UNUSED --detect.output.path="/blackduck/output" --detect.status.json.output.path="/blackduck/status"
    - fi

deploy-ser:
  tags:
    - docker-ex
  stage: preparesecurity
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: always
    - when: manual
  script:
    - cd security
    - docker compose -f compose.qlt.yml up -d

cleanup-ser:
  tags:
    - docker-ex
  stage: cleansecurity
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: always
    - when: manual
  needs:
    - deploy-ser
  script:
    - cd security
    - docker compose -f compose.qlt.yml down -v
